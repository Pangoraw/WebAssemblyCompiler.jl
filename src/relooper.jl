module Relooper

using ..WebAssemblyCompiler: CompilerContext, _compile
using ..LibBinaryen

import Core.Compiler: DomTree, dominates, IRCode, CFG, BasicBlock

"""
    RelooperState(ctx, exprs, cfg)

This struct contains the state needed to transform the `goto` style control flow
of Julia SSAIR to WebAssembly valid control flow using `Loop`, `Block` and `If`
constructs.

The implementation is based on the paper:

> Beyond Relooper, Recursive Generation of WebAssembly \\
> ICFP 2022, Norman Ramsey

The core API to use the relooper is to call `reloop(ctx, exprs, cfg)` which will return
a re-looped single instruction.
"""
struct RelooperState
    ctx::CompilerContext
    # We already have emitted the code for each block content
    exprs::Vector{BinaryenExpressionRef}
    cfg::CFG
    domtree::DomTree
    order::Vector{Int}
end

_copy(cfg) = CFG(copy(cfg.blocks), copy(cfg.index))

function RelooperState(ctx, exprs, cfg)
    exprs, cfg, domtree = reduce!(ctx, exprs, _copy(cfg))
    RelooperState(
        ctx,
        exprs,
        cfg,
        domtree,
        reverse_postorder(domtree.dfs_tree),
    )
end

function reverse_postorder(dfs)
    postorder = dfs.to_post # bb -> order
    rev_postorder = similar(postorder)
    # post_order -> bb
    for (i, b) in enumerate(sortperm(postorder; rev=true))
        rev_postorder[b] = i
    end
    rev_postorder
end

function block_label(l)
    "block_$l"
end

"""
    ismergenode(relooper, bidx) -> Bool

N.B. A block is a merge node if it is where control flow merges.
That means it is entered by multiple control-flow edges, _except_
back edges don't count.  There must be multiple paths that enter the
block _without_ passing through the block itself.
Merge nodes are positioned after other dominated blocks which are not
merge nodes such that each ancestor in the dominator tree is able to
jump to a merge node.

Consider the following CFG:

```
  A
 ↙ ↘
B   C
 ↘ ↙
  D
```

Here D is a merge node, immediately dominated by A. It will result in the
following wasm control flow.

```
block
  A
  if
    B
  else
    C
  end
  D
end
```
"""
function ismergenode(relooper::RelooperState, bidx)
    block = relooper.cfg.blocks[bidx]
    count(b -> !iszero(b) && relooper.order[b] < relooper.order[bidx], block.preds) >= 2
end

"""
    isloopheader(relooper, bidx) -> Bool

N.B. A block is a loop header if any edge flows backward to it.
Self-loop also count. A loop header if represented using the `Loop`
Wasm construct.

In the following control flow graph, B is a loop header since the
reverse post-order is the following [A:1, B:2, C:3] and therefore
the edge from C to B is backward (order[C] >= order[B]).

```
A
↓
B←┐
↓ |
C-┘
```
"""
function isloopheader(relooper::RelooperState, bidx)
    block = relooper.cfg.blocks[bidx]
    any(b -> relooper.order[b] >= relooper.order[bidx], filter(!iszero, block.preds))
end

"""
    istryblock(relooper, bidx) -> Bool

N.B. A try block in this context corresponds to the entry block
of a region generated by a try/catch block. The try block usually
contains a single `:enter` instruction.

```
try            CodeInfo(
    A          1 ─ %1 = \$(Expr(:enter, #4))
               2 ─ %2 = Main.A
               └──      \$(Expr(:leave, 1))
               3 ─      return %2
catch          4 ┄      \$(Expr(:leave, 1))
    B          5 ─ %6 = Main.B
               │        \$(Expr(:pop_exception, :(%1)))
end            └──      return %6
               )
```

The try block dominates its successors which therefore will be nested
inside the `try`/`try_table` and `catch` instructions.

Phase 2:

```wat
try
    A
catch $jl_exception_tag
    B
end
```

Phase 3:

```wat
block $out
    try_table (catch_all $handler) $handler
        A

        br $out
    end
    B
end
```
"""
function istryblock(relooper::RelooperState, bidx)
    (; ctx, cfg) = relooper
    (; ci) = ctx
    b = cfg.blocks[bidx]
    Meta.isexpr(ci.code[last(b.stmts)], :enter)
end

function getcatchblock(relooper::RelooperState, bidx)
    (; ctx, cfg) = relooper
    (; ci) = ctx
    b = cfg.blocks[bidx]
    inst = ci.code[last(b.stmts)]
    @assert Meta.isexpr(inst, :enter)
    Core.Compiler.block_for_inst(relooper.cfg, only(inst.args))
end

function dobranch(relooper::RelooperState, source, target)
    # Jumping backward means that the block is dominated by the loop header
    # therefore the target is present in the context and the jump can be
    # represented with a `br` instruction.
    if !(relooper.order[target] > relooper.order[source]) # isbackward
        label = block_label(target)
        return BinaryenBreak(relooper.ctx.mod, label, C_NULL, C_NULL)
    end

    # The target is a merge node, it means that it is positioned after
    # the source block and is present in the context to jump to with a
    # `br` instruction.
    if ismergenode(relooper, target) # ismergelabel
        label = block_label(target)
        return BinaryenBreak(relooper.ctx.mod, label, C_NULL, C_NULL)
    end

    # Otherwise, we can simply inline the code for the target block in-place.
    @debug "succ" source target
    donode!(relooper, target)
end

isreturn(relooper, bidx) = relooper.ctx.ci.code[relooper.cfg.blocks[bidx].stmts.stop] isa Core.ReturnNode
isunreachable(relooper, bidx) = isreturn(relooper, bidx) &&
                                !isdefined(relooper.ctx.ci.code[relooper.cfg.blocks[bidx].stmts.stop], :val)

function getsuccs(relooper, bidx)
    ci = relooper.ctx.ci
    block = relooper.cfg.blocks[bidx]
    @assert length(block.succs) <= 2

    gotoifnot = ci.code[last(block.stmts)]
    if length(block.succs) == 1
        return only(block.succs), nothing, nothing
    end

    if gotoifnot isa Core.GotoNode
        gotoifnot = ci.code[block.stmts.stop - 1]::Core.GotoIfNot
    end

    falsedest = gotoifnot.dest
    cond = gotoifnot.cond

    # From codeinfo to ircode style
    falsedest = Core.Compiler.block_for_inst(relooper.cfg, falsedest)

    truedest = block.succs[1] == falsedest ? last(block.succs) : first(block.succs)

    if !(truedest in relooper.cfg.blocks[bidx].succs)
        return tuple(relooper.cfg.blocks[bidx].succs..., cond)
    end

    return truedest, falsedest, cond
end

function nestwithin!(relooper::RelooperState, bidx, mergenodes)
    if isempty(mergenodes)
        if isreturn(relooper, bidx)
            return relooper.exprs[bidx]
        end

        if istryblock(relooper, bidx)
            cblock = getcatchblock(relooper, bidx)
            tblock = setdiff(relooper.cfg.blocks[bidx].succs, cblock) |> only

            try_code = dobranch(relooper, bidx, tblock)
            catch_code = dobranch(relooper, bidx, cblock)

            if BinaryenGetTag(relooper.ctx.mod, "jl_exception_tag") == C_NULL
                BinaryenAddTag(relooper.ctx.mod, "jl_exception_tag", BinaryenTypeNone(), BinaryenTypeNone())
            end

            try_inst = BinaryenTry(
                relooper.ctx.mod,
                C_NULL,
                try_code,
                ["jl_exception_tag"],
                1,
                [catch_code],
                1,
                C_NULL,
            )

            return BinaryenBlock(
                relooper.ctx.mod,
                C_NULL,
                BinaryenExpressionRef[relooper.exprs[bidx], try_inst], # NOTE: should relooper.exprs[bidx] be included in try?
                2,
                BinaryenTypeAuto(),
            )
        end

        truedest, falsedest, cond = getsuccs(relooper,bidx)

        if isnothing(falsedest)
            BinaryenBlockAppendChild(
                relooper.exprs[bidx],
                dobranch(relooper, bidx, truedest),
            )
        else
            BinaryenBlockAppendChild(
                relooper.exprs[bidx],
                BinaryenIf(
                    relooper.ctx.mod,
                    _compile(relooper.ctx, cond),
                    dobranch(relooper, bidx, truedest),
                    dobranch(relooper, bidx, falsedest),
                ),
            )
        end
        return relooper.exprs[bidx]
    end

    # y_n has a higher reverse postorder indexing
    # which means that it should be placed *after* other
    # mergenodes. We therefore push it in the context before
    # other mergenodes.
    (ys..., y_n) = mergenodes

    codeforx = BinaryenBlock(
        relooper.ctx.mod,
        block_label(y_n),
        BinaryenExpressionRef[nestwithin!(relooper, bidx, ys)],
        1,
        BinaryenTypeAuto(),
    )
    BinaryenBlock(
        relooper.ctx.mod,
        C_NULL,
        BinaryenExpressionRef[codeforx, donode!(relooper, y_n)],
        2,
        BinaryenTypeAuto(),
    )
end

function donode!(relooper::RelooperState, bidx)
    (; domtree) = relooper

    # When placing a block, we also place all successors in the
    # dominator tree.
    toplace = sort(domtree.nodes[bidx].children, by=b -> relooper.order[b])

    # Out of the immediately dominated blocks, merge nodes have a
    # special handling since they are placed after.
    mergenodes = filter(b -> ismergenode(relooper, b), toplace)

    # Very verbose
    # @debug "placing" bidx toplace mergenodes

    if isloopheader(relooper, bidx)
        block = relooper.cfg.blocks[bidx]

        # Each loop must have a single entry point, otherwise the CFG
        # is not reducible. So all edges must either be forward or the
        # current block must dominate the predecessor for a backward edge.
        @assert all(b -> relooper.order[b] < relooper.order[bidx] ||
                         dominates(relooper.domtree, bidx, b),
                    block.preds) "CFG is not reducible"

        codeforx = nestwithin!(relooper, bidx, mergenodes)
        BinaryenLoop(relooper.ctx.mod, block_label(bidx), codeforx)
    else
        codeforx = nestwithin!(relooper, bidx, mergenodes)
        BinaryenBlock(
            relooper.ctx.mod,
            C_NULL,
            BinaryenExpressionRef[codeforx], 1,
            BinaryenTypeAuto(),
        )
    end
end

reloop!(relooper::RelooperState) = donode!(relooper, 1)

"""
    reloop(mod, exprs::Vector{BinaryenExpressionRef}, cfg) -> BinaryenExpressionRef

Consumes the given expressions (one for each block in `cfg.blocks`) and return_
a single expression list which contains the WebAssembly structured control flow constructs
such as `Block`, `If` and `Loop` and which uses `br` instructions instead of arbitrary goto jumps.
"""
function reloop(ctx, exprs, cfg)
    relooper = RelooperState(ctx, exprs, cfg)
    b = reloop!(relooper)
    BinaryenBlock(
        ctx.mod,
        C_NULL,
        BinaryenExpressionRef[
            b,
            BinaryenUnreachable(ctx.mod),
        ], # CF will go through a ReturnNode
        2,
        BinaryenTypeAuto(),
    )
end

# --- Irreducible CFG ---

const BBNumber = Int

struct SuperNode
    head::BBNumber
    nodes::Vector{BBNumber}
end

"""
    SuperGraph(ctx, exprs, cfg)

State needed to perform the node splitting algorithm from the "Dragon book"

> Compilers - Principles, Techniques, and Tools \\
> Aho et al., sec 9.7.5.

with the implementation described in

> Beyond Relooper, Recursive Generation of WebAssembly \\
> ICFP 2022, Norman Ramsey
"""
mutable struct SuperGraph
    const ctx::CompilerContext
    exprs::Vector{BinaryenExpressionRef}
    domtree::DomTree
    const cfg::CFG
    const nodes::Vector{SuperNode}
end
function SuperGraph(ctx, exprs, cfg::CFG)
    n_blocks = length(cfg.blocks)
    domtree = Core.Compiler.construct_domtree(cfg.blocks)
    SuperGraph(ctx, exprs, domtree, cfg, [
        SuperNode(b, BBNumber[b])
        for b in 1:n_blocks
    ])
end

"""
    reduce!(ctx, exprs, cfg::CFG) -> (Vector{BinaryenExpressionRef}, CFG, DomTree)

Transforms an irreducible in a reducible CFG by performing
node-splitting. See [`SuperGraph`](@ref).
"""
function reduce!(ctx, exprs, cfg)
    # TODO: better unreachable blocks handling
    REDUCE_TIMEOUT = 10

    sg = SuperGraph(ctx, exprs, cfg)

    tt = 0
    while length(sg.nodes) != 1 && tt <= REDUCE_TIMEOUT
        while merge!(sg) end
        split!(sg)
        tt += 1
    end

    # verifycfg(cfg) # toggle this to verify
    return sg.exprs, sg.cfg, sg.domtree
end

"control-flow predecessors of the super-node U in the super-graph sg"
predecessors(sg, U) =
    filter!(!iszero, setdiff(sg.cfg.blocks[U.head].preds, U.nodes))

"""
    merge!(sg::SuperGraph) -> Bool

Merges two super nodes together, for example, the following supergraph where
each CFG node is initially its own supernode will sequentially be merged in
the following supernodes.

```
  A
 ↙ ↘      1. Merge: [(A), (B), (C), (D)] -> [(A,B), (C), (D)]
B   C     2. Merge: [(A,B), (C), (D)]    -> [(A,B,C), (D)]
 ↘ ↙      3. Merge: [(A,B,C), (D)]       -> [(A,B,C,D)]
  D
```

having a single node, after a series of merge means that the CFG is reducible.
If merging cannot be performed and there are more than one supernode, one of them
needs to be split using `split!`. Returns false if no super-node was merged, true
otherwise.
"""
function merge!(sg)
    for u in eachindex(sg.nodes)
        for v in eachindex(sg.nodes)
            u == v && continue

            U = sg.nodes[u]
            V = sg.nodes[v]

            dominates(sg.domtree, V.head, U.head) || continue

            preds = predecessors(sg, U)
            if !isempty(preds) && preds ⊆ V.nodes
                deleteat!(sg.nodes, u)
                union!(V.nodes, U.nodes)
                return true
            end
        end
    end
    return false
end

function split!(sg)
    for i in eachindex(sg.nodes)
        X = sg.nodes[i]

        preds = predecessors(sg, X)
        Ws = filter(W -> !isdisjoint(W.nodes, preds), sg.nodes)
        isempty(Ws) && continue

        # Create Xᵢ foreach Wᵢ ∈ Ws
        for Wᵢ in @view Ws[begin+1:end]
            n_blocks = length(sg.cfg.blocks)

            map_block(x) = x ∈ X.nodes ? findfirst(==(x), X.nodes) + n_blocks : x
            Xᵢ = SuperNode(
                map_block(X.head),
                map(map_block, X.nodes),
            )

            get_block = Base.Fix1(getindex, sg.cfg.blocks)
            new_blocks = [
                BasicBlock(
                    b.stmts,
                    map(map_block, b.preds) ∩ (Xᵢ.nodes ∪ Wᵢ.nodes),
                    map(map_block, b.succs) ∩ (Xᵢ.nodes ∪ Wᵢ.nodes),
                )
                for b in map(get_block, X.nodes)
            ]
            new_exprs = [
                BinaryenExpressionCopy(sg.exprs[i], sg.ctx.mod)
                for b in X.nodes
            ]

            for W in Wᵢ.nodes
                W_block = sg.cfg.blocks[W]
                union!(W_block.preds, map(map_block, W_block.preds))
                map!(map_block, W_block.succs, W_block.succs)
            end

            for x in X.nodes
                x_block = sg.cfg.blocks[x]
                setdiff!(x_block.preds, Wᵢ.nodes)
            end

            append!(sg.exprs, new_exprs)
            append!(sg.cfg.blocks, new_blocks)
            append!(sg.cfg.index, map(i -> sg.cfg.index[i], X.nodes))
            push!(sg.nodes, Xᵢ)
        end

        # NOTE: do not rebuild the CFG domtree everytime
        sg.domtree = Core.Compiler.construct_domtree(sg.cfg.blocks)
        return true
    end
    return false
end

# Verify that we have not broken the CFG
function verifycfg(cfg)
   for (i, b) in enumerate(cfg.blocks)
       for p in b.preds
          @assert iszero(p) || i ∈ cfg.blocks[p].succs p => i
       end
       for s in b.succs
           @assert i ∈ cfg.blocks[s].preds i => s
       end
   end
end

end # module Relooper
