var documenterSearchIndex = {"docs":
[{"location":"notes/#Notes","page":"Notes","title":"Notes","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"WebAssembly's Tuples and Structs cannot be indexed dynamically. Only fixed integer indexing works. So, Tuples are mapped as follows:\nNTuple -> WebAssembly's Fixed Array\nTuple -> WebAssembly's Tuple or Struct. The Struct will GC. WebAssembly's Tuple is more for handling multiple return values. The only option for dynamic indexing is some sort of table lookup.  \nThere is no equivalent of stack-allocated Tuples for StaticArrays. There are Fixed Arrays that are heap allocated. Maybe the browser can convert some of those to stack values. Bumper could substitute for stack allocation.\nYou can't get a pointer from GC heap-allocated arrays. You can't reinterpret or use pointer operations. You can have a buffer and pull in individual values and reinterpret those. That's slow, though.\nException handling doesn't work. The compiler doesn't currently handle PhiC nodes or Upsilon nodes in the SSA IR. Binaryen and WebAssembly support try, catch, and throw, so there's no technical reason this can't be supported.\nSimilarly error handling isn't attempted. Overlays are used to bypass error code to make things compile.\nThe compiler includes some known bandaids and rough spots.\nIn compile_block, the handling of QuoteNodes and Core.Const wrappers is uneven. Handling is included in a spotty fashion, but a more consistent approach would be better.\nOn the WebAssembly side, on-the-fly type detection doesn't work. Heap objects are not stored with type information. It would be possible to add type info to all types. Guile Hoot does this by adding a type hash to every struct.\nUnion's are not supported, and the path to supporting them is unclear. WebAssembly's type system doesn't have anything like that, and it also doesn't allow re-interpeting content easily.\nSeveral intrinsics are not supported. Some are challenging. do_apply / _apply_iterate look tough.\nSeveral of the existing intrinsics only support basic types (Int32, Int64, etc.). Better handling of these would be nice.\nString support is very limited. JavaScript is used to concatenate using string(...). JavaScript uses UTF16 for strings, and Julia's String uses UTF8. WebAssembly supports different string encodings and conversions. Right now, Strings are stored as GC'd UTF8 vectors. These are converted to JavaScript strings on the JavaScript side. No character-level operations are supported. In the future, the stringref proposal will improve string interop. String hashing isn't supported, and that's needed for Dicts with Strings.\nSymbols are currently converted straight to strings. That allows basic operations to work, including comparisons. This simple approach may cause issues for some code.\nBinaryen doesn't do any auto-vectorization. WebAssembly has basic SIMD types, but none are supported by WebAssemblyCompiler. \nLoopVectorization doesn't work. It's LLVM specific.\nUsing overlays with @jscall of normal Julia code will block constant propagation by the Julia compiler because the Julia compiler can't know what's happening and can't run it in the existing process.  \nWebAssembly doesn't support circular references, but Julia does. What we do is assign a default value for the circular reference and hope it doesn't cause problems. This works for the Observables support because the circular references aren't used after the set of Observables is statically compiled.\nThe support of aliased objects may still be patchy. Some were fixed up recently, but I worry that some still lurk (meaning you might get a copy when you want two references to point to the same object).","category":"page"},{"location":"notes/#Comparing-Approaches-to-Generating-WebAssembly","page":"Notes","title":"Comparing Approaches to Generating WebAssembly","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"StaticCompiler can also generate WebAssembly from Julia code. Some of the advantages of that approach include:","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"LLVM generates fast code.\nThe package is simple (GPUCompiler and Julia's compiler does all the work).","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"The main disadvantages of StaticCompiler are:","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"No GC built in.\nNo clear path to include libjulia capability, so no GC, and everything must be manually allocated (StaticTools).\nNo global variables.\nThe Julia compiler doesn't make a good cross compiler. For example, indexes into structs sometimes use the host index and sometimes the target index (discussions).","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"The compiler in this project is better in some ways, including:","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"Support for WebAssembly GC (structs, strings, arrays, ...).\nGood interop with JavaScript.\nCan tailor compilation to WebAssembly better.\nHacking the compiler is easier.","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"The downsides of this approach are:","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"Code isn't as good as LLVM's. The biggest issue may be no autovectorization.\nWebAssembly's type system is limited. This should improve in the future.\nNo nested structs or arrays of structs; nesting boxes everything; use StructArrays, ComponentArrays, ValueShapes, or other Julia packages to organize nested data using flat arrays.\nAll structs are boxed.\nBrowser support for WASM-GC is just beginning.\nMore bugs.","category":"page"},{"location":"notes/#Project-ideas","page":"Notes","title":"Project ideas","text":"","category":"section"},{"location":"notes/#BLAS","page":"Notes","title":"BLAS","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"Implement replacements for key BLAS functionality. This could be tackled by compiling an existing library to WebAssembly (like BLIS) or by implementing functionality in Julia.","category":"page"},{"location":"notes/#Makie","page":"Notes","title":"Makie","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"Makie in the browser would be so useful. Plot directly via WebGL or WebGPU.","category":"page"},{"location":"notes/#Robust-Array-support","page":"Notes","title":"Robust Array support","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"Once the Memory type PR is merged, update the Array support in WebAssemblyCompiler. Support grow and multidimensional arrays.","category":"page"},{"location":"notes/#Vectorization-/-SIMD","page":"Notes","title":"Vectorization / SIMD","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"WebAssembly supports basic SIMD types. There are several ways that could be incorporated:","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"Write a Binaryen pass to do auto-vectorization (C++).\nFor loops with @simd, vectorize those with Julia. This would be at the typed IR level.\nAdd support for WebAssembly's basic SIMD types.","category":"page"},{"location":"notes/#Implement-Int128","page":"Notes","title":"Implement Int128","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"Use of Int128's is common in Julia code, but it's not a native WebAssembly type. Add a package to mimic Int128's which can be incorporated using overlays.","category":"page"},{"location":"notes/#Exception-handling","page":"Notes","title":"Exception handling","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"Handle PhiC and Upsilon nodes in the SSA IR. WebAssembly has throw and other exception-handling features. This might need the equivalent of relooping but for exceptions.","category":"page"},{"location":"notes/#Union-types","page":"Notes","title":"Union types","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"WebAssembly doesn't have this capability, so some mechanism would be needed to mimic these.","category":"page"},{"location":"notes/#CI-/-testing","page":"Notes","title":"CI / testing","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"Update NodeCall to support the latest WebAssembly features, and update tests (issue).","category":"page"},{"location":"notes/#Convert-/-test-your-favorite-package","page":"Notes","title":"Convert / test your favorite package","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"Compiling code using key packages would help improve the code.","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"EditURL = \"../../../examples/lorenz/lorenz.jl\"","category":"page"},{"location":"examples/lorenz/#Lorenz-model-using-OrdinaryDiffEq","page":"Lorenz model","title":"Lorenz model using OrdinaryDiffEq","text":"","category":"section"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"using WebAssemblyCompiler     # prep some input #hideall   #hide\nusing WebAssemblyCompiler.JS: h   #hide\nconst W = WebAssemblyCompiler   #hide\nW.setdebug(:offline)   #hide\n   #hide\nnumform(name; mdpad = \"name\", step = 1, value = 1, args...) =   #hide\n     h.div.\"field has-addons\"(   #hide\n       h.p.\"control\"(   #hide\n         h.a.\"button is-static\"(   #hide\n           name   #hide\n         )   #hide\n       ),   #hide\n       h.p.\"control\"(   #hide\n         h.input.\"input\"(;type = \"number\", mdpad, step, value, args...)   #hide\n       ),   #hide\n     )   #hide\n h.div(   #hide\n     h.div.\"columns is-vcentered\"(   #hide\n         h.div.\"column\"(   #hide\n             h.form(   #hide\n                 numform(\"σ\", mdpad = \"p1\", step = 0.2, value = 10.0),   #hide\n                 numform(\"ρ\", mdpad = \"p2\", step = 1.0, value = 28.0),   #hide\n                 numform(\"β\", mdpad = \"p3\", step = 0.1, value = 8 / 3),   #hide\n             )   #hide\n         ),   #hide\n         h.div.\"column\"(   #hide\n             h.div(id = \"xyplot\")   #hide\n         )   #hide\n     ),   #hide\n     h.div(id = \"timeplot\")   #hide\n )   #hide","category":"page"},{"location":"examples/lorenz/#Making-the-app","page":"Lorenz model","title":"Making the app","text":"","category":"section"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"Here is the model that we'll compile.","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"using OrdinaryDiffEq\nusing WebAssemblyCompiler\n\nfunction lorenz!(du,u,p,t)\n    σ,ρ,β = p\n    du[1] = σ*(u[2]-u[1])\n    du[2] = u[1]*(ρ-u[3]) - u[2]\n    du[3] = u[1]*u[2] - β*u[3]\nend\n\nu0 = [1.0,0.0,0.0]\ntspan = (0.0,100.0)\np = (10.0,28.0,8/3)\nprob = ODEProblem{true, SciMLBase.FullSpecialize}(lorenz!,u0,tspan,p)  # try to avoid FunctionWrappers with FullSpecialize\n\nconst integ = init(prob, Tsit5(), dense = true)\nnothing #hide","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"Here's a simple solver function. It references integ, a predefined integrator. WebAssembly stores that as a global variable.","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"function update()\n    OrdinaryDiffEq.reinit!(integ)\n    integ.p = update_params()\n    sol = solve!(integ)\n    t = collect(0:0.001:100)\n    u1 = Float64[sol(tt)[1] for tt in t]\n    u2 = Float64[sol(tt)[2] for tt in t]\n    u3 = Float64[sol(tt)[3] for tt in t]\n    update_output(t, u1, u2, u3)\n    nothing\nend\nnothing #hide","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"These utilities update the page inputs.","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"mdpadnum(x) = @jscall(\"x => mdpad[x]\", Float64, Tuple{Externref}, JS.object(x))\nupdate_params() = (mdpadnum(\"p1\"), mdpadnum(\"p2\"), mdpadnum(\"p3\"))\nnothing #hide","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"This function plots the results.","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"@inline function update_output(t, u1, u2, u3)\n    xydata = ((x = u1, y = u2, type = \"line\", name = \"x\"),)\n    xylayout = (width = 400.0, height = 400.0, margin = (t = 20., b = 20., l = 20., r = 20.))\n    config = (responsive = true,)\n    plotly(\"xyplot\", xydata, xylayout, config)\n    tdata = ((x = t, y = u1, type = \"line\", name = \"x\"),\n             (x = t, y = u2, type = \"line\", name = \"y\"),\n             (x = t, y = u3, type = \"line\", name = \"z\"))\n    tlayout = (width = 900.0, height = 300.0, margin = (t = 20., b = 20.))\n    plotly(\"timeplot\", tdata, tlayout, config)\n    nothing\nend\nplotly(id, data, layout, config) =\n    @jscall(\"(id, data, layout, config) => Plotly.newPlot(id, data, layout, config)\",\n        Nothing, Tuple{Externref, Externref, Externref, Externref},\n        JS.object(id), data, layout, config)\nnothing #hide","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"Before compiling, we need to override some error checks that caused failures.","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"using Base.Experimental: @overlay\n@overlay WebAssemblyCompiler.MT @inline SciMLBase.check_error(integrator::SciMLBase.DEIntegrator) = SciMLBase.ReturnCode.Success\n# The following function includes a try/catch, so bypass it.\n@overlay WebAssemblyCompiler.MT @inline OrdinaryDiffEq.ode_determine_initdt(args...; kw...) = 0.001\nnothing #hide","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"Compile update to WebAssembly:","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"compile((update,); filepath = \"lorenz/lorenz.wasm\", validate = true)\nnothing #hide","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"update() runs automatically whenever inputs are changed.","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"examples/lorenz.jl also includes some raw HTML to load Plotly and mdpad and to load the WebAssembly file.","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"<script>\n    // Weird hack to load Plotly: https://stackoverflow.com/a/3363588\n    // https://github.com/JuliaDocs/Documenter.jl/issues/12471\n    window.__define = window.define;\n    window.__require = window.require;\n    window.define = undefined;\n    window.require = undefined;\n</script>\n<script src=\"https://cdn.plot.ly/plotly-2.26.0.min.js\" charset=\"utf-8\"></script>\n<script>\n    window.define = window.__define;\n    window.require = window.__require;\n    window.__define = undefined;\n    window.__require = undefined;\n</script>\n<script src=\"../../js/mdpad.js\" ></script>\n<script src=\"lorenz.wasm.js\"></script>\n<script>\nsetTimeout(function() {\n  var x = document.getElementById(\"xyplot\")\n  if (x.innerHTML === \"\") {\n      x.innerHTML = \"<strong>Unsupported browser.</strong> Chrome v119 or Firefox v120 or better should work.\"\n  }\n}, 1000)\nasync function mdpad_init() {\n    const fetchPromise = fetch('lorenz.wasm');\n    const { instance } = await WebAssembly.instantiateStreaming(fetchPromise, jsexports);\n    wasm = instance.exports;\n}\nfunction mdpad_update() {\n    wasm.update()\n}\n</script>","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Main-API","page":"API","title":"Main API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"compile is the main method exported by WebAssemblyCompiler.","category":"page"},{"location":"api/","page":"API","title":"API","text":"compile","category":"page"},{"location":"api/#WebAssemblyCompiler.compile","page":"API","title":"WebAssemblyCompiler.compile","text":"compile(funs::Tuple...; filepath = \"foo.wasm\", jspath = filepath * \".js\", names = nothing, validate = true, optimize = false, experimental = true)\n\nCompile the methods defined by funs. Each function definition to be compiled is a tuple with the first entry as the function followed by argument types. Keyword arguments include:\n\nfilepath–File path for the WebAssembly binary. The path will be created if it doesn't exist.\njspath–File path for the extra JavaScript file that defines jsexports which are the JS functions imported into WebAssembly (those normally defined by @jscall). \nnames–A vector or other indexable object with names of functions that are compiled. It's length must equal the length of funs.\nvalidate–Apply Binaryen's validation tests.\noptimize–Apply Binaryen's default optimization passes (still shaky).\nexperimental–Use experimental WebAssembly features.\n\ncompile also writes a WebAssembly text tile to the same path as filepath with an added \".wat\" extension.\n\nExamples:\n\ncompile((exp, Float64), filepath = \"exp.wasm\", optimize = true)   \ncompile((acos, Float64), (asin, Float64), filepath = \"trigs.wasm\", optimize = true)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Debugging is often needed when trying to fix code to make it compile.","category":"page"},{"location":"api/","page":"API","title":"API","text":"You can enable debugging output using:","category":"page"},{"location":"api/","page":"API","title":"API","text":"WebAssemblyCompiler.debug(x)","category":"page"},{"location":"api/","page":"API","title":"API","text":"where x is :inline to display debugging information at the REPL  or :offline do store information in WebAssemblyCompiler.DEBUG. Outputs from that are stored in WebAssemblyCompiler.DEBUG, include:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Julia IR for each method compiled\nWebAssembly code generated for each statement","category":"page"},{"location":"api/#JavaScript-interoperability","page":"API","title":"JavaScript interoperability","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"WebAssemblyCompiler provides several utilities to ease interoperability with the browser. The main way to call JavaScript methods is with @jscall (exported):","category":"page"},{"location":"api/","page":"API","title":"API","text":"@jscall","category":"page"},{"location":"api/#WebAssemblyCompiler.@jscall","page":"API","title":"WebAssemblyCompiler.@jscall","text":"@jscall(fun, rettype, tt, args...)\n\nCall a JavaScript function fun.  fun is a string and normally includes the JavaScript function definition. Under the hood, these use Base.llvmcall. All @jscall definitions are imported from JavaScript.\n\nrettype, tt, ang args... all follow the Base.llvmcall format. tt is a Tuple type (not a regular Tuple).\n\nArguments are converted to the types specified in tt. The following types can be included: String, Int64, Int32, UInt64,  UInt32, Float64, Float32, Char, Bool, UInt8, and Int8. For all other types, specify Externref.  Externref types are converted with JS.object.\n\nExamples:     @jscall(\"x => alert(x)\", Nothing, Tuple{String}, x)     d = @jscall(\"() => getElementById('someid')\", Externref, Tuple{})     @jscall(\"d => d.innerHTML = 'hello world'\", Nothing, Tuple{Externref}, d)\n\n@jscall is used extensively in quirks.jl and  javascript-interop.jl.\n\n\n\n\n\n","category":"macro"},{"location":"api/","page":"API","title":"API","text":"Objects on the JavaScript side are accessed using the Externref type (exported):","category":"page"},{"location":"api/","page":"API","title":"API","text":"Externref","category":"page"},{"location":"api/#WebAssemblyCompiler.Externref","page":"API","title":"WebAssemblyCompiler.Externref","text":"Externref()\n\nA type representing an external object in the host system (JavaScript). This object can be passed around, but no direct operations are supported. The object can be passed back to JavaScript methods.  To convert a Julia object to an Externref, use JS.object. \n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"The module JS provides several utility functions to help with browser interoperability. The JS module is exported, but its methods are not.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [WebAssemblyCompiler.JS]\nOrder   = [:function, :macro, :type]","category":"page"},{"location":"api/#WebAssemblyCompiler.JS.console_log-Tuple{Externref}","page":"API","title":"WebAssemblyCompiler.JS.console_log","text":"Applies JavaScript's console.log to show x in the browser log. Returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAssemblyCompiler.JS.escape-Tuple{Any}","page":"API","title":"WebAssemblyCompiler.JS.escape","text":"escape(x)\n\nReplaces HTML-specific characters in the string x with encoded versions. It converts '&', '\"', ''', '<', and '>'. \n\n\n\n\n\n","category":"method"},{"location":"api/#WebAssemblyCompiler.JS.eval-Tuple{Any}","page":"API","title":"WebAssemblyCompiler.JS.eval","text":"Evaluate the JavaScript string x. Returns an Externref.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAssemblyCompiler.JS.getelementbyid-Tuple{Any}","page":"API","title":"WebAssemblyCompiler.JS.getelementbyid","text":"Returns a DOM object based on document.getElementById(x).\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAssemblyCompiler.JS.h-Tuple{Any, Vararg{Any}}","page":"API","title":"WebAssemblyCompiler.JS.h","text":"h(tag, children...; kw...)\nh.tag(children...; kw...)\nh.tag.\"classes\"(children...; kw...)\n\nCreate an html node with the given tag, children, and kw attributes.\n\nExamples\n\nh.div(\"child\", class=\"myclass\", id=\"myid\")\n# <div class=\"myclass\" id=\"myid\">child</div>\n\nh.div.\"myclass\"(\"content\")\n# <div class=\"myclass\">content</div>\n\nAdapted from Cobweb. h uses the same API as Cobweb.h, except for getindex with symbols. For WebAssemblyCompiler.h, the following are equivalent:\n\nh.div.\"myclass\"(\"content\")\nh.div.myclass(\"content\")\n\nNote that strings are not encoded, so be sure not to include problematic HTML characters like <.  Use escape or esc\"...\" to fix strings with problematic characters.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAssemblyCompiler.JS.object-Tuple{Union{Bool, Float32, Float64, Int32, Externref}}","page":"API","title":"WebAssemblyCompiler.JS.object","text":"object(x)\n\nReturn an Externref (JavaScript object) representing the Julia object x. This is useful for transfering arrays, named tuples, and other objects to JavaScript.\n\nThe types Int32, Float32, Float64, Bool, and Externref  are passed stright through.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAssemblyCompiler.JS.sethtml-Tuple{Externref, Any}","page":"API","title":"WebAssemblyCompiler.JS.sethtml","text":"Sets the innerHTML of the DOM object ref to str.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAssemblyCompiler.JS.@esc_str-Tuple{Any}","page":"API","title":"WebAssemblyCompiler.JS.@esc_str","text":"esc\"...\"\n\nUses escape to fix up an HTML string.\n\nExample\n\nesc\"An HTML string with problematic characters, including ', >, and &\"\n\n\n\n\n\n","category":"macro"},{"location":"api/#WebAssemblyCompiler.JS.Node","page":"API","title":"WebAssemblyCompiler.JS.Node","text":"Node(tag::String, attrs::NamedTuple, children::Tuple)\n\nShould not often be used directly.  See h.\n\n\n\n\n\n","category":"type"},{"location":"api/#Overlays","page":"API","title":"Overlays","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"It is common to need to swap out problematic parts of code when compiling to WebAssembly. The compilation pipeline uses Base.Experimental.@overlay to methods to be redefined.  Here is an example of redefining Base.log10:","category":"page"},{"location":"api/","page":"API","title":"API","text":"using Base.Experimental: @overlay\n@overlay WebAssemblyCompiler.MT Base.log10(x::Float64) = @jscall(\"(x) => Math.log10(x)\", Float64, Tuple{Float64}, x)","category":"page"},{"location":"api/","page":"API","title":"API","text":"WebAssemblyCompiler.MT is the MethodTable that is used during compilation.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Redefinitions built into WebAssemblyCompiler are defined in  quirks.jl. Many math functions are replaced by JavaScript versions. Many error functions are also replaced.","category":"page"},{"location":"api/#Mixtape-support","page":"API","title":"Mixtape support","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Overlays are the most common way to manipulate code for compilation. More advanced manipulation is possible with Mixtape support built in.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Mixtape support is considered experimental and not part of the official API. This support has not been tested extensively.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Mixtape is enabled using the following methods and types (none are exported):","category":"page"},{"location":"api/","page":"API","title":"API","text":"WebAssemblyCompiler.CompilationContext \nWebAssemblyCompiler.allow \nWebAssemblyCompiler.transform ","category":"page"},{"location":"api/#WebAssemblyCompiler.CompilationContext","page":"API","title":"WebAssemblyCompiler.CompilationContext","text":"abstract type CompilationContext end\n\nParametrize the Mixtape pipeline by inheriting from CompilationContext. Similar to the context objects in Cassette.jl. By using the interface methods transform – the user can control different parts of the compilation pipeline.\n\n\n\n\n\n","category":"type"},{"location":"api/#WebAssemblyCompiler.allow","page":"API","title":"WebAssemblyCompiler.allow","text":"allow(f::CompilationContext, args...)::Bool\n\nDetermines whether the user-defined transform is allowed to look at a lowered Core.CodeInfo or Core.Compiler.IRCode instance.\n\nThe user is allowed to greenlight modules:\n\nallow(::MyCtx, m::Module) == m == SomeModule\n\nor even specific signatures\n\nallow(::MyCtx, fn::typeof(rand), args...) = true\n\n\n\n\n\n","category":"function"},{"location":"api/#WebAssemblyCompiler.transform","page":"API","title":"WebAssemblyCompiler.transform","text":"transform(ctx::CompilationContext, b::Core.CodeInfo)::Core.CodeInfo\ntransform(ctx::CompilationContext, b::Core.CodeInfo, sig::Tuple)::Core.CodeInfo\n\nUser-defined transform which operates on lowered Core.CodeInfo. There's two versions: (1) ignores the signature of the current method body under consideration and (2) provides the signature as sig.\n\nTransforms might typically follow a simple \"swap\" format using CodeInfoTools.Builder:\n\nfunction transform(::MyCtx, src)\n    b = CodeInfoTools.Builder(b)\n    for (k, st) in b\n        b[k] = swap(st))\n    end\n    return CodeInfoTools.finish(b)\nend\n\nbut more advanced formats are possible. For further utilities, please see CodeInfoTools.jl.\n\n\n\n\n\n","category":"function"},{"location":"api/#Binaryen-utilities","page":"API","title":"Binaryen utilities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Binaryen binary utilities from Binaryen_jll  such as wasm-dis are available in WebAssemblyCompiler.Bin.","category":"page"},{"location":"api/","page":"API","title":"API","text":"This is not official API in terms of semver.  Each release of WebAssemblyCompiler targets a specific version of Binaryen.  There are no compatibility guarantees between versions of Binaryen.  These are unlikely to change though.","category":"page"},{"location":"api/#LibBinaryen","page":"API","title":"LibBinaryen","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The C interface to Binaryen is provided through WebAssemblyCompiler.LibBinaryen. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"This is not official API in terms of semver.  Each release of WebAssemblyCompiler targets a specific version of Binaryen.  There are no compatibility guarantees between versions of Binaryen.","category":"page"},{"location":"examples/observables/","page":"Observables","title":"Observables","text":"EditURL = \"../../../examples/observables/observables.jl\"","category":"page"},{"location":"examples/observables/#Making-an-SVG-using-Observables","page":"Observables","title":"Making an SVG using Observables","text":"","category":"section"},{"location":"examples/observables/","page":"Observables","title":"Observables","text":"This app mimics this JSServe app but with interactivity provided by Julia code compiled to WebAssembly.","category":"page"},{"location":"examples/observables/","page":"Observables","title":"Observables","text":"using WebAssemblyCompiler     # prep some input #hideall   #hide\nusing WebAssemblyCompiler.JS: h   #hide\nconst W = WebAssemblyCompiler   #hide\nW.setdebug(:offline)   #hide\nW.unsetdebug(:inline)   #hide\n   #hide\nusing Observables   #hide\n   #hide\nconst names = []   #hide\nconst os = []   #hide\n   #hide\nfunction numform(description; jl = description, step = 1, value = 1, args...)   #hide\n    push!(names, jl)   #hide\n    push!(os, Observable(value))   #hide\n    h.div.\"field\"(   #hide\n        h.label.\"label\"(   #hide\n          description   #hide\n        ),   #hide\n        h.div.\"control\"(   #hide\n            h.input.\"input\"(;type = \"number\", step, value, onchange = \"document.wasm.$jl(this.value)\", args...)   #hide\n        ),   #hide\n    )   #hide\nend   #hide\n   #hide\nhtml = h.div(   #hide\n    h.div.\"columns is-vcentered\"(   #hide\n        h.div.\"column is-2\"(   #hide\n            h.form(   #hide\n                numform(\"nsamples\", step = 5, value = Int32(100), min = 5, max = 1000),   #hide\n                numform(\"steps\", jl = \"sample_step\", step = 0.02, value = 0.1, min = 0.02, max = 1.0),   #hide\n                numform(\"phase\", step = 0.25, value = 0.0, min = 0.0, max = 3.0),   #hide\n                numform(\"radii\", step = 5.0, value = 10.0, min = 1.0, max = 40.0),   #hide\n            )   #hide\n        ),   #hide\n        h.div.\"column\"(   #hide\n            h.div(id = \"plot\")   #hide\n        )   #hide\n    ),   #hide\n)   #hide","category":"page"},{"location":"examples/observables/#Making-the-app","page":"Observables","title":"Making the app","text":"","category":"section"},{"location":"examples/observables/","page":"Observables","title":"Observables","text":"Observables are used widely by Julia packages to provide interactivity. For static compilation, they are problematic, though. The Observable type is not strongly typed, and it's challenging to compile statically.","category":"page"},{"location":"examples/observables/","page":"Observables","title":"Observables","text":"What we can do is define some Observables and some interactivity and compile the results.","category":"page"},{"location":"examples/observables/","page":"Observables","title":"Observables","text":"First, we'll create the basics for the updating SVG.","category":"page"},{"location":"examples/observables/","page":"Observables","title":"Observables","text":"const colors = [\"black\", \"gray\", \"silver\", \"maroon\", \"red\", \"olive\", \"yellow\", \"green\", \"lime\", \"teal\", \"aqua\", \"navy\", \"blue\", \"purple\", \"fuchsia\"]\n\nfunction circ(cx, cy, r, icol)\n    [\"<circle cx='\", cx, \"' cy='\", cy, \"' r='\", r, \"' fill='\", colors[icol % length(colors) + 1], \"'></circle>\"]\nend\n\nfunction set_svg(nsamples, sample_step, phase, radii)\n    width, height = 900.0, 300.0\n    cxs_unscaled = [i*sample_step + phase for i in 1:nsamples]\n    cys = [sin(cxs_unscaled[i]) * height/3 + height/2 for i in 1:nsamples]\n    cxs = [cxs_unscaled[i] * width/4pi for i in 1:nsamples]\n    rr = radii\n    # make an array of strings and numbers to join in JavaScript\n    geom = Any[\"<svg width=\", width, \" height=\", height, \" ><g>\"]\n    for i in 1:nsamples\n        append!(geom, circ(cxs[i], cys[i], rr, i))\n    end\n    push!(geom, \"</g></svg>\")\n    obj = JS.object(geom)\n    geom = JS.join(obj)\n    JS.sethtml(\"plot\", geom)\nend\nnothing #hide","category":"page"},{"location":"examples/observables/","page":"Observables","title":"Observables","text":"The method set_svg is what we'll ultimately want to compile.","category":"page"},{"location":"examples/observables/","page":"Observables","title":"Observables","text":"To get there, we need the code that'll compile the Observables. The fix! methods take a set of Observables, walk their connections, and return a set of methods that will update the Observables provided. These methods unroll calls to the listeners of each Observable to make it easier to statically compile.","category":"page"},{"location":"examples/observables/","page":"Observables","title":"Observables","text":"using Observables\n\nfix!(os::AbstractObservable...) = fix!(Set{AbstractObservable}(), os...)\n\nfunction fix!(ctx::Set{AbstractObservable}, x...)\nend\n\nfunction fix!(ctx::Set{AbstractObservable}, observables::Observable...)\n    setfuns = []\n    notifies = []\n    for observable in observables\n        observable in ctx && continue\n        push!(ctx, observable)\n        push!(setfuns, (makeset(ctx, observable), typeof(observable.val)))\n    end\n    return setfuns\nend\nfunction makeset(ctx::Set{AbstractObservable}, o::Observable)\n    listeners = tuple((fix!(ctx, l[2]) for l in o.listeners)...)\n    return val -> begin\n        o.val = Observables.to_value(val)\n        nnotify(o, listeners...)\n    end\nend\nfunction fix!(ctx::Set{AbstractObservable}, oa::Observables.OnAny)\n    return OnAnyHolder(oa.f, tuple(oa.args...))\n    return val -> begin\n        f(valargs(args...)...)\n        return Consume(false)\n    end\nend\nmutable struct OnAnyHolder{F,A}\n    f::F\n    args::A\nend\nfunction (x::OnAnyHolder)(val)\n    x.f(valargs(x.args...)...)\n    return Consume(false)\nend\n\nfunction fix!(ctx::Set{AbstractObservable}, mc::Observables.MapCallback)\n    set! = makeset(ctx, mc.result)\n    result = mc.result\n    resultlisteners = tuple((fix!(ctx, l[2]) for l in result.listeners)...)\n    return MapCallbackHolder(mc.result, mc.f, tuple(mc.args...), resultlisteners)\nend\n\nmutable struct MapCallbackHolder{O,F,A,L}\n    result::O\n    f::F\n    args::A\n    listeners::L\nend\nfunction (x::MapCallbackHolder)(val)\n    x.result.val = x.f(valargs(x.args...)...)\n    nnotify(x.result, x.listeners...)\n    return Consume(false)\nend\n\n@inline valargs() = ()\n@inline valargs(x) = (Observables.to_value(x),)\n@inline valargs(x, xs...) = (Observables.to_value(x), valargs(xs...)...)\n\n@inline nnotify(o::Observable) = nothing\n@inline nnotify(::Nothing) = nothing\n@inline function nnotify(o::Observable, f)\n    result = f(o.val)\n    result.x && return true\n    return false\nend\n@inline function nnotify(o::Observable, f, fs...)\n    nnotify(o, f)\n    nnotify(o, fs...)\n    return false\nend\nnothing #hide","category":"page"},{"location":"examples/observables/","page":"Observables","title":"Observables","text":"We also need to patch up some internals in WebAssemblyCompiler. WebAssembly doesn't handle circular references. As a kludge, we assign defaults to circular references. We're okay with that here because these circular references are never used.","category":"page"},{"location":"examples/observables/","page":"Observables","title":"Observables","text":"W.default(o::Observable{T}) where T = Observable(o.val)\nnothing #hide","category":"page"},{"location":"examples/observables/","page":"Observables","title":"Observables","text":"The last part is pretty simple. We'll call onany to connect our set of input Observables os to the set_svg method. fix! returns a named tuple with a setfuns component that can be passed to compile. Each setfuns method is passed a value appropriate for that Observable. This triggers propagation of updates to the listeners.","category":"page"},{"location":"examples/observables/","page":"Observables","title":"Observables","text":"onany(set_svg, os...)\nsetfuns! = fix!(os...)\ncompile(setfuns!...; names = names, filepath = \"observables/observables.wasm\")\nnothing #hide","category":"page"},{"location":"examples/observables/","page":"Observables","title":"Observables","text":"With this interactivity provided by Observables, we've eliminated almost all of the JavaScript. JS.h methods are used to define the inputs, including an onupdate trigger that calls the appropriate WebAssembly function. These also define Observables and collect names for the WebAssembly functions. See examples/observables.jl for the complete source for this example.","category":"page"},{"location":"examples/observables/","page":"Observables","title":"Observables","text":"<script src=\"observables.wasm.js\"></script>\n<script type=\"module\">\nsetTimeout(function() {\n  var x = document.getElementById(\"plot\")\n  if (x.innerHTML === \"\") {\n      x.innerHTML = \"<strong>Unsupported browser.</strong> Chrome v119 or Firefox v120 or better should work.\"\n  }\n}, 1000)\nexport async function load_wasm() {\n  const response = await fetch('observables.wasm');\n  const bytes = await response.arrayBuffer();\n  const { instance } = await WebAssembly.instantiate(bytes, jsexports);\n  const { basics } = instance.exports;\n  return instance.exports;\n}\ndocument.wasm = await load_wasm();\ndocument.wasm.radii(10.);\n</script>","category":"page"},{"location":"#Compile-Julia-code-to-WebAssembly","page":"Introduction","title":"Compile Julia code to WebAssembly","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package uses Binaryen to compile Julia's IR to WebAssembly.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Experimental and in progress\nThis code is experimental. Expect to find errors or failures when compiling Julia code.This uses not-yet-final features of WebAssembly.  A bleeding-edge browser is needed.  As of now, only Chrome dev version 119 or higher works. In Chrome's chrome://flags/, the following flags need to be enabled:Experimental WebAssembly \nWebAssembly Garbage Collection\nWebAssembly Stringref","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"WebAssemblyCompiler supports many Julia constructs, including:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Vector{T} where T is a bitstype and Vector{Any}\nStrings\nSymbols\nDicts (not including strings)\nMutable and immutable structs\nTuples and NamedTuples\nGlobal variables\nVarargs and keyword arguments","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Heap allocation is handled by WebAssembly's garbage collector (see wasm-GC).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Interoperability with JavaScript is quite good. Julia code can run JavaScript functions and exchange objects. This functionality allows Julia to interact with the browsers DOM.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Code must be type stable (no dynamic dispatches). In addition, several Julia constructs are not supported, including:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Multi-dimensional arrays (waiting on the Memory type PR)\nPointers\nUnion types\nException handling\nErrors\nSome integer types (Int16, Int128, ...)\nBLAS and all other C dependencies","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"WebAssemblyCompiler supports overlays and other ways to fix up code when compiling.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Once compiled to WebAssembly, you can integrate that into web apps in many ways. The examples in these docs are made with:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Literate.jl–The Julia files in /examples can run standalone, or they can be used with Franklin or Documenter (as done here).\nmdpad–This small JavaScript package provides features for single-page web apps, including auto-updates of inputs and address-bar handling.\nBulma–Any CSS framework should work. Because Documenter uses a theme based on Bulma, that is used for styling web apps.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The web apps are very Julia focused. Not much JavaScript is needed.","category":"page"}]
}
