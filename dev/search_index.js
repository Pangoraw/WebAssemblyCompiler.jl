var documenterSearchIndex = {"docs":
[{"location":"notes/#Notes","page":"Notes","title":"Notes","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"WebAssembly's Tuples and Structs cannot be indexed dynamically. Only fixed integer indexing works. So, Tuples are mapped as follows:\nNTuple -> WebAssembly's Fixed Array\nTuple -> WebAssembly's Tuple or Struct. The Struct will GC. WebAssembly's Tuple is more for handling multiple return values. The only option for dynamic indexing is some sort of table lookup.  \nThere is no equivalent of stack-allocated Tuples for StaticArrays. There are Fixed Arrays that are heap allocated. Maybe the browser can convert some of those to stack values. Bumper could substitute for stack allocation.\nYou can't get a pointer from GC heap-allocated arrays. You can't reinterpret or use pointer operations. You can have a buffer and pull in individual values and reinterpret those. That's slow, though.\nException handling doesn't work. The compiler doesn't currently handle PhiC nodes or Upsilon nodes in the SSA IR. Binaryen and WebAssembly support try, catch, and throw, so there's no technical reason this can't be supported.\nSimilarly error handling isn't attempted. Overlays are used to bypass error code to make things compile.\nThe compiler includes some known bandaids and rough spots.\nIn compile_block, the handling of QuoteNodes and Core.Const wrappers is uneven. Handling is included in a spotty fashio, but a more consistent approach would be better.\nOn the WebAssembly side, on-the-fly type detection doesn't work. Heap objects are not stored with type information. It would be possible to add type info to all types. Guile Hoot does this by adding a type hash to every struct.\nUnion's are not supported, and the path to supporting them is unclear. WebAssembly's type system doesn't have anything like that, and it also doesn't allow re-interpeting content easily.\nSeveral intrinsics are not supported. Some are challenging.\nSeveral of the existing intrinsics only support basic types (Int32, Int64, etc.). Better handling of these would be nice.\nString support is still limited. JavaScript is used to concatenate using string(...). JavaScript uses UTF16 for strings, and Julia's String uses UTF8. WebAssembly supports different string encodings and conversions. Right now, Strings are left as JavaScript strings. No character-level operations are supported. In the future, it may be best to match Julia's UTF8 format, but then strings would need to be converted when exchanged with JavaScript. Maybe different string options could be implemented.\nSymbols are currently converted straight to strings. That allows basic operations to work, including comparisons. This simple approach may cause issues for some code.\nBinaryen doesn't do any auto-vectorization. WebAssembly has basic SIMD types, but none are supported by WebAssemblyCompiler. Options to improve this situation include:\nWrite a Binaryen pass to do auto-vectorization.\nFor loops with @simd, try to vectorize those.\nAdd support for basic SIMD types.\nLoopVectorization doesn't work. It's LLVM specific.","category":"page"},{"location":"notes/#Comparing-Approaches-to-Generating-WebAssembly","page":"Notes","title":"Comparing Approaches to Generating WebAssembly","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"StaticCompiler can also generate WebAssembly from Julia code. Some of the advantages of that approach include:","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"LLVM generates fast code.\nThe package is simple (GPUCompiler and Julia's compiler does all the work).","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"The main disadvantages of StaticCompiler are:","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"No GC built in.\nNo clear path to include libjulia capability, so no GC, and everything must be manually allocated (StaticTools).\nNo global variables.\nThe Julia compiler doesn't make a good cross compiler. For example, indexes into structs sometimes use the host index and sometimes the target index (discussions).","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"The compiler in this project is better in some ways, including:","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"Support for WebAssembly GC (structs, strings, arrays, ...).\nGood interop with JavaScript.\nCan tailor compilation to WebAssembly better.\nHacking the compiler is easier.","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"The downsides of this approach are:","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"Code isn't as good as LLVM's. The biggest issue may be no autovectorization.\nWebAssembly's type system is limited. This should improve in the future.\nNo nested structs or arrays of structs; nesting boxes everything; use StructArrays, ComponentArrays, ValueShapes, or other Julia packages to organize nested data using flat arrays.\nAll structs are boxed.\nBrowser support for WASM-GC is just beginning.\nMore bugs.","category":"page"},{"location":"notes/#TODO","page":"Notes","title":"TODO","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"Here is a list of some things that are not implemented.","category":"page"},{"location":"notes/#SSA-IR-/-exception-handling","page":"Notes","title":"SSA IR / exception handling","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"PhiC nodes\nUpsilon nodes","category":"page"},{"location":"notes/#Intrinsics-/-Builtins","page":"Notes","title":"Intrinsics / Builtins","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"Several","category":"page"},{"location":"notes/#Types","page":"Notes","title":"Types","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"String concatenation\nUnions\nsvec","category":"page"},{"location":"notes/#JS-integration","page":"Notes","title":"JS integration","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"Structs to objects","category":"page"},{"location":"notes/#libjulia","page":"Notes","title":"libjulia","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"IO","category":"page"},{"location":"notes/#Tests","page":"Notes","title":"Tests","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"Updated NodeCall","category":"page"},{"location":"notes/#Other","page":"Notes","title":"Other","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"unsafe_copyto! - needs overlay\nSplit up tests","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"EditURL = \"../../../examples/lorenz/lorenz.jl\"","category":"page"},{"location":"examples/lorenz/#Lorenz-model-using-OrdinaryDiffEq","page":"Lorenz model","title":"Lorenz model using OrdinaryDiffEq","text":"","category":"section"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"using WebAssemblyCompiler     # prep some input #hideall   #hide\nusing WebAssemblyCompiler.JS: h   #hide\nconst W = WebAssemblyCompiler   #hide\nnumform(name; mdpad = \"name\", step = 1, value = 1) =   #hide\n     h.div.\"field has-addons\"(   #hide\n       h.p.\"control\"(   #hide\n         h.a.\"button is-static\"(   #hide\n           name   #hide\n         )   #hide\n       ),   #hide\n       h.p.\"control\"(   #hide\n         h.input.\"input\"(;type = \"number\", mdpad, step, value)   #hide\n       ),   #hide\n     )   #hide\n h.div(   #hide\n     h.div.\"columns is-vcentered\"(   #hide\n         h.div.\"column\"(   #hide\n             h.form(   #hide\n                 numform(\"σ\", mdpad = \"p1\", step = 0.2, value = 10.0),   #hide\n                 numform(\"ρ\", mdpad = \"p2\", step = 1.0, value = 28.0),   #hide\n                 numform(\"β\", mdpad = \"p3\", step = 0.1, value = 8 / 3),   #hide\n             )   #hide\n         ),   #hide\n         h.div.\"column\"(   #hide\n             h.div(id = \"xyplot\")   #hide\n         )   #hide\n     ),   #hide\n     h.div(id = \"timeplot\")   #hide\n )   #hide","category":"page"},{"location":"examples/lorenz/#Making-the-app","page":"Lorenz model","title":"Making the app","text":"","category":"section"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"Here is the model that we'll compile.","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"using OrdinaryDiffEq\nusing WebAssemblyCompiler\n\nfunction lorenz!(du,u,p,t)\n    σ,ρ,β = p\n    du[1] = σ*(u[2]-u[1])\n    du[2] = u[1]*(ρ-u[3]) - u[2]\n    du[3] = u[1]*u[2] - β*u[3]\nend\n\nu0 = [1.0,0.0,0.0]\ntspan = (0.0,100.0)\np = (10.0,28.0,8/3)\nprob = ODEProblem{true, SciMLBase.FullSpecialize}(lorenz!,u0,tspan,p)  # try to avoid FunctionWrappers with FullSpecialize\n\nconst integ = init(prob, Tsit5())\ninteg.opts.adaptive = false\nnothing #hide","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"Here's a simple solver function. It references integ, a predefined integrator. WebAssembly stores that as a global variable.","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"function update()\n    reinit!(integ)\n    integ.p = update_params()\n    integ.dt = 0.005\n    n = 10000\n    tres = zeros(n)\n    u1 = zeros(n)\n    u2 = zeros(n)\n    u3 = zeros(n)\n    u1[5] = 99.0\n    for i in 1:n\n        ret = OrdinaryDiffEq.perform_step!(integ, integ.cache)\n        OrdinaryDiffEq.recursivecopy!(integ.uprev, integ.u)\n        OrdinaryDiffEq.recursivecopy!(integ.fsalfirst, integ.fsallast)\n        integ.t = integ.t + integ.dt\n        integ.tprev = integ.t\n        tres[i] = integ.t\n        u1[i] = integ.u[1]\n        u2[i] = integ.u[2]\n        u3[i] = integ.u[3]\n    end\n    update_output(tres, u1, u2, u3)\n    nothing\nend\nnothing #hide","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"The following include simpler versions of OrdinaryDiffEq.reinit! and OrdinaryDiffEq.initialize!.","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"function reinit!(integrator::OrdinaryDiffEq.ODEIntegrator, u0 = integrator.sol.prob.u0;\n    t0 = integrator.sol.prob.tspan[1],\n    tf = integrator.sol.prob.tspan[2],\n    )\n\n    OrdinaryDiffEq.recursivecopy!(integrator.u, u0)\n    OrdinaryDiffEq.recursivecopy!(integrator.uprev, integrator.u)\n\n    integrator.t = t0\n    integrator.tprev = t0\n\n    tspan = (t0, tf)\n\n    integrator.iter = 0\n    integrator.success_iter = 0\n    integrator.u_modified = false\n\n    initialize!(integrator, integrator.cache)\nend\nnothing #hide\n\nfunction initialize!(integrator, cache)\n    integrator.kshortsize = 7\n    integrator.fsalfirst = cache.k1\n    integrator.fsallast = cache.k7 # setup pointers\n    resize!(integrator.k, integrator.kshortsize)\n    integrator.k[1] = cache.k1\n    integrator.k[2] = cache.k2\n    integrator.k[3] = cache.k3\n    integrator.k[4] = cache.k4\n    integrator.k[5] = cache.k5\n    integrator.k[6] = cache.k6\n    integrator.k[7] = cache.k7\n    integrator.f(integrator.fsalfirst, integrator.uprev, integrator.p, integrator.t) # Pre-start fsal\n    integrator.stats.nf += 1\n    nothing\nend\nnothing #hide","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"These utilities update the page inputs.","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"mdpadnum(x) = @jscall(\"x => mdpad[x]\", Float64, Tuple{String}, x)\nupdate_params() = (mdpadnum(\"p1\"), mdpadnum(\"p2\"), mdpadnum(\"p3\"))\nnothing #hide","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"This function plots the results.","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"@inline function update_output(t, u1, u2, u3)\n    xydata = ((x = u1, y = u2, type = \"line\", name = \"x\"),)\n    xylayout = (width = 400.0, height = 400.0, margin = (t = 20., b = 20., l = 20., r = 20.))\n    config = (responsive = true,)\n    plotly(\"xyplot\", xydata, xylayout, config)\n    tdata = ((x = t, y = u1, type = \"line\", name = \"x\"),\n             (x = t, y = u2, type = \"line\", name = \"y\"),\n             (x = t, y = u3, type = \"line\", name = \"z\"))\n    tlayout = (width = 900.0, height = 300.0, margin = (t = 20., b = 20.))\n    plotly(\"timeplot\", tdata, tlayout, config)\n    nothing\nend\nplotly(id, data, layout, config) =\n    @jscall(\"(id, data, layout, config) => Plotly.newPlot(id, data, layout, config)\",\n        Nothing, Tuple{String, Externref, Externref, Externref},\n        id, data, layout, config)\nnothing #hide","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"Before compiling, we need to override some error checks that caused failures.","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"using Base.Experimental: @overlay\n@overlay WebAssemblyCompiler.MT @inline SciMLBase.check_error(integrator::SciMLBase.DEIntegrator) = SciMLBase.ReturnCode.Success\nnothing #hide","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"Compile update to WebAssembly:","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"compile((update,); filepath = \"lorenz/lorenz.wasm\", validate = true)","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"update() runs automatically whenever inputs are changed.","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"examples/lorenz.jl also includes some raw HTML to load Plotly and mdpad and to load the WebAssembly file.","category":"page"},{"location":"examples/lorenz/","page":"Lorenz model","title":"Lorenz model","text":"<script>\n    // Weird hack to load Plotly: https://stackoverflow.com/a/3363588\n    // https://github.com/JuliaDocs/Documenter.jl/issues/12471\n    window.__define = window.define;\n    window.__require = window.require;\n    window.define = undefined;\n    window.require = undefined;\n</script>\n<script src=\"https://cdn.plot.ly/plotly-2.26.0.min.js\" charset=\"utf-8\"></script>\n<script>\n    window.define = window.__define;\n    window.require = window.__require;\n    window.__define = undefined;\n    window.__require = undefined;\n</script>\n<script src=\"../../js/mdpad.js\" ></script>\n<script src=\"lorenz.wasm.js\"></script>\n<script>\nasync function mdpad_init() {\n    const fetchPromise = fetch('lorenz.wasm');\n    const { instance } = await WebAssembly.instantiateStreaming(fetchPromise, jsexports);\n    wasm = instance.exports;\n}\nfunction mdpad_update() {\n    wasm.update()\n}\n</script>","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Main-API","page":"API","title":"Main API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"compile is the main method exported by WebAssemblyCompiler.","category":"page"},{"location":"api/","page":"API","title":"API","text":"compile","category":"page"},{"location":"api/#WebAssemblyCompiler.compile","page":"API","title":"WebAssemblyCompiler.compile","text":"compile(funs::Tuple...; filepath = \"foo.wasm\", jspath = filepath * \".js\", validate = true, optimize = false, experimental = true)\n\nCompile the methods defined by funs. Each function definition to be compiled is a tuple with the first entry as the function followed by argument types. Keyword arguments include:\n\nfilepath–File path for the WebAssembly binary. The path will be created if it doesn't exist.\njspath–File path for the extra JavaScript file that defines jsexports which are the JS functions imported into WebAssembly (those normally defined by @jscall). \nvalidate–Apply Binaryen's validation tests.\noptimize–Apply Binaryen's default optimization passes (still shaky).\nexperimental–Use experimental WebAssembly features.\n\ncompile also writes a WebAssembly text tile to the same path as filepath with an added \".wat\" extension.\n\nExamples:\n\ncompile((exp, Float64), filepath = \"exp.wasm\", optimize = true)   \ncompile((acos, Float64), (asin, Float64), filepath = \"trigs.wasm\", optimize = true)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Debugging is often needed when trying to fix code to make it compile.","category":"page"},{"location":"api/","page":"API","title":"API","text":"You can enable debugging output using:","category":"page"},{"location":"api/","page":"API","title":"API","text":"const WebAssemblyCompiler._DEBUG_ = true","category":"page"},{"location":"api/","page":"API","title":"API","text":"Outputs include:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Julia IR for each method compiled\nWebAssembly code generated for each statement","category":"page"},{"location":"api/#JavaScript-interoperability","page":"API","title":"JavaScript interoperability","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"WebAssemblyCompiler provides several utilities to ease interoperability with the browser. The main way to call JavaScript methods is with @jscall (exported):","category":"page"},{"location":"api/","page":"API","title":"API","text":"@jscall","category":"page"},{"location":"api/#WebAssemblyCompiler.@jscall","page":"API","title":"WebAssemblyCompiler.@jscall","text":"@jscall(fun, rettype, tt, args...)\n\nCall a JavaScript function fun.  fun is a string and normally includes the JavaScript function definition. Under the hood, these use Base.llvmcall. All @jscall definitions are imported from JavaScript.\n\nrettype, tt, ang args... all follow the Base.llvmcall format. tt is a Tuple type (not a regular Tuple).\n\nArguments are converted to the types specified in tt. The following types can be included: String, Int64, Int32, UInt64,  UInt32, Float64, Float32, Char, Bool, UInt8, and Int8. For all other types, specify Externref.  Externref types are converted with JS.object.\n\nExamples:     @jscall(\"x => alert(x)\", Nothing, Tuple{String}, x)     d = @jscall(\"() => getElementById('someid')\", Externref, Tuple{})     @jscall(\"d => d.innerHTML = 'hello world'\", Nothing, Tuple{Externref}, d)\n\n@jscall is used extensively in quirks.jl and  javascript-interop.jl.\n\n\n\n\n\n","category":"macro"},{"location":"api/","page":"API","title":"API","text":"Objects on the JavaScript side are accessed using the Externref type (exported):","category":"page"},{"location":"api/","page":"API","title":"API","text":"Externref","category":"page"},{"location":"api/#WebAssemblyCompiler.Externref","page":"API","title":"WebAssemblyCompiler.Externref","text":"Externref()\n\nA type representing an external object in the host system (JavaScript). This object can be passed around, but no direct operations are supported. The object can be passed back to JavaScript methods.  To convert a Julia object to an Externref, use JS.object. \n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"The module JS provides several utility functions to help with browser interoperability. The JS module is exported, but its methods are not.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [WebAssemblyCompiler.JS]\nOrder   = [:function, :macro, :type]","category":"page"},{"location":"api/#WebAssemblyCompiler.JS.console_log-Tuple{Externref}","page":"API","title":"WebAssemblyCompiler.JS.console_log","text":"Applies JavaScript's console.log to show x in the browser log. Returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAssemblyCompiler.JS.escape-Tuple{Any}","page":"API","title":"WebAssemblyCompiler.JS.escape","text":"escape(x)\n\nReplaces HTML-specific characters in the string x with encoded versions. It converts '&', '\"', ''', '<', and '>'. \n\n\n\n\n\n","category":"method"},{"location":"api/#WebAssemblyCompiler.JS.eval-Tuple{String}","page":"API","title":"WebAssemblyCompiler.JS.eval","text":"Evaluate the JavaScript string x. Returns an Externref.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAssemblyCompiler.JS.getelementbyid-Tuple{Any}","page":"API","title":"WebAssemblyCompiler.JS.getelementbyid","text":"Returns a DOM object based on document.getElementById(x).\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAssemblyCompiler.JS.h-Tuple{Any, Vararg{Any}}","page":"API","title":"WebAssemblyCompiler.JS.h","text":"h(tag, children...; kw...)\nh.tag(children...; kw...)\nh.tag.\"classes\"(children...; kw...)\n\nCreate an html node with the given tag, children, and kw attributes.\n\nExamples\n\nh.div(\"child\", class=\"myclass\", id=\"myid\")\n# <div class=\"myclass\" id=\"myid\">child</div>\n\nh.div.\"myclass\"(\"content\")\n# <div class=\"myclass\">content</div>\n\nAdapted from Cobweb. h uses the same API as Cobweb.h, except for getindex with symbols. For WebAssemblyCompiler.h, the following are equivalent:\n\nh.div.\"myclass\"(\"content\")\nh.div.myclass(\"content\")\n\nNote that strings are not encoded, so be sure not to include problematic HTML characters like <.  Use escape or esc\"...\" to fix strings with problematic characters.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAssemblyCompiler.JS.object-Tuple{Union{Bool, Float32, Float64, Int32, Externref, String, Symbol}}","page":"API","title":"WebAssemblyCompiler.JS.object","text":"object(x)\n\nReturn an Externref (JavaScript object) representing the Julia object x. This is useful for transfering arrays, named tuples, and other objects to JavaScript.\n\nThe types Int32, Float32, Float64, Bool, String, Symbol, and Externref  are passed stright through.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAssemblyCompiler.JS.sethtml-Tuple{Externref, String}","page":"API","title":"WebAssemblyCompiler.JS.sethtml","text":"Sets the innerHTML of the DOM object ref to str.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAssemblyCompiler.JS.@esc_str-Tuple{Any}","page":"API","title":"WebAssemblyCompiler.JS.@esc_str","text":"esc\"...\"\n\nUses escape to fix up an HTML string.\n\nExample\n\nesc\"An HTML string with problematic characters, including ', >, and &\"\n\n\n\n\n\n","category":"macro"},{"location":"api/#WebAssemblyCompiler.JS.Node","page":"API","title":"WebAssemblyCompiler.JS.Node","text":"Node(tag::String, attrs::NamedTuple, children::Tuple)\n\nShould not often be used directly.  See h.\n\n\n\n\n\n","category":"type"},{"location":"api/#Overlays","page":"API","title":"Overlays","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"It is common to need to swap out problematic parts of code when compiling to WebAssembly. The compilation pipeline uses Base.Experimental.@overlay to methods to be redefined.  Here is an example of redefining Base.log10:","category":"page"},{"location":"api/","page":"API","title":"API","text":"using Base.Experimental: @overlay\n@overlay WebAssemblyCompiler.MT Base.log10(x::Float64) = @jscall(\"(x) => Math.log10(x)\", Float64, Tuple{Float64}, x)","category":"page"},{"location":"api/","page":"API","title":"API","text":"WebAssemblyCompiler.MT is the MethodTable that is used during compilation.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Redefinitions built into WebAssemblyCompiler are defined in  quirks.jl. Many math functions are replaced by JavaScript versions. Many error functions are also replaced.","category":"page"},{"location":"api/#Mixtape-support","page":"API","title":"Mixtape support","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Overlays are the most common way to manipulate code for compilation. More advanced manipulation is possible with Mixtape support built in.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Mixtape support is considered experimental and not part of the official API. This support has not been tested extensively.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Mixtape is enabled using the following methods and types (none are exported):","category":"page"},{"location":"api/","page":"API","title":"API","text":"WebAssemblyCompiler.CompilationContext \nWebAssemblyCompiler.allow \nWebAssemblyCompiler.transform ","category":"page"},{"location":"api/#WebAssemblyCompiler.CompilationContext","page":"API","title":"WebAssemblyCompiler.CompilationContext","text":"abstract type CompilationContext end\n\nParametrize the Mixtape pipeline by inheriting from CompilationContext. Similar to the context objects in Cassette.jl. By using the interface methods transform – the user can control different parts of the compilation pipeline.\n\n\n\n\n\n","category":"type"},{"location":"api/#WebAssemblyCompiler.allow","page":"API","title":"WebAssemblyCompiler.allow","text":"allow(f::CompilationContext, args...)::Bool\n\nDetermines whether the user-defined transform is allowed to look at a lowered Core.CodeInfo or Core.Compiler.IRCode instance.\n\nThe user is allowed to greenlight modules:\n\nallow(::MyCtx, m::Module) == m == SomeModule\n\nor even specific signatures\n\nallow(::MyCtx, fn::typeof(rand), args...) = true\n\n\n\n\n\n","category":"function"},{"location":"api/#WebAssemblyCompiler.transform","page":"API","title":"WebAssemblyCompiler.transform","text":"transform(ctx::CompilationContext, b::Core.CodeInfo)::Core.CodeInfo\ntransform(ctx::CompilationContext, b::Core.CodeInfo, sig::Tuple)::Core.CodeInfo\n\nUser-defined transform which operates on lowered Core.CodeInfo. There's two versions: (1) ignores the signature of the current method body under consideration and (2) provides the signature as sig.\n\nTransforms might typically follow a simple \"swap\" format using CodeInfoTools.Builder:\n\nfunction transform(::MyCtx, src)\n    b = CodeInfoTools.Builder(b)\n    for (k, st) in b\n        b[k] = swap(st))\n    end\n    return CodeInfoTools.finish(b)\nend\n\nbut more advanced formats are possible. For further utilities, please see CodeInfoTools.jl.\n\n\n\n\n\n","category":"function"},{"location":"api/#Binaryen-utilities","page":"API","title":"Binaryen utilities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Binaryen binary utilities from Binaryen_jll  such as wasm-dis are available in WebAssemblyCompiler.Bin.","category":"page"},{"location":"api/","page":"API","title":"API","text":"This is not official API in terms of semver.  Each release of WebAssemblyCompiler targets a specific version of Binaryen.  There are no compatibility guarantees between versions of Binaryen.  These are unlikely to change though.","category":"page"},{"location":"api/#LibBinaryen","page":"API","title":"LibBinaryen","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The C interface to Binaryen is provided through WebAssemblyCompiler.LibBinaryen. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"This is not official API in terms of semver.  Each release of WebAssemblyCompiler targets a specific version of Binaryen.  There are no compatibility guarantees between versions of Binaryen.","category":"page"},{"location":"examples/basics/","page":"JS interop","title":"JS interop","text":"EditURL = \"../../../examples/basics/basics.jl\"","category":"page"},{"location":"examples/basics/#Basic-JavaScript-interop","page":"JS interop","title":"Basic JavaScript interop","text":"","category":"section"},{"location":"examples/basics/","page":"JS interop","title":"JS interop","text":"This example generates HTML from Julia and inserts the contents here:","category":"page"},{"location":"examples/basics/","page":"JS interop","title":"JS interop","text":"","category":"page"},{"location":"examples/basics/","page":"JS interop","title":"JS interop","text":"<div id=\"myid\"></div>","category":"page"},{"location":"examples/basics/","page":"JS interop","title":"JS interop","text":"","category":"page"},{"location":"examples/basics/","page":"JS interop","title":"JS interop","text":"Here is the Julia code to be compiled to WebAssembly. In addition to the use of JS.h, this example also shows the use of JS.sethtml, JS.eval, and JS.console_log.","category":"page"},{"location":"examples/basics/","page":"JS interop","title":"JS interop","text":"using WebAssemblyCompiler\nconst h = JS.h\n\nfunction basics(x)\n    n = h(\"p\",\n          h(\"strong\", \" This is strong text with a class.\"), class = \"myclass\")\n    n = h(\"div\", \"This is some text generated by `JS.h`. \",\n          \"This is a number: \", x, n, class = \"myclass2\")\n    JS.sethtml(\"myid\", string(n))\n    # JS.eval(\"alert('Generated by Julia')\")  # It works, but it's too annoying.\n    JS.console_log((arr = [1., 2., 3.], str = \"hello\", num = 2.0, tp = (3, 3.)))\n    return x\nend\nnothing #hide","category":"page"},{"location":"examples/basics/","page":"JS interop","title":"JS interop","text":"Compile it using:","category":"page"},{"location":"examples/basics/","page":"JS interop","title":"JS interop","text":"compile((basics, Float64); filepath = \"basics/basics.wasm\", validate = true, optimize = false)","category":"page"},{"location":"examples/basics/","page":"JS interop","title":"JS interop","text":"<script src=\"basics.wasm.js\"></script>\n<script type=\"module\">\n    export async function load_wasm() {\n        const response = await fetch('basics.wasm');\n        const bytes = await response.arrayBuffer();\n        const { instance } = await WebAssembly.instantiate(bytes, jsexports);\n        const { basics } = instance.exports;\n        return instance.exports;\n    }\n    var wasm = await load_wasm();\n    console.log(wasm.basics(3.0));\n</script>","category":"page"},{"location":"#Compile-Julia-code-to-WebAssembly","page":"Introduction","title":"Compile Julia code to WebAssembly","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package uses Binaryen to compile Julia's IR to WebAssembly.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Experimental and in progress\nThis code is experimental. Expect to find errors or failures when compiling Julia code.This uses not-yet-final features of WebAssembly.  A bleeding-edge browser is needed.  As of now, only Chrome dev version 119 or higher works. In Chrome's chrome://flags/, the following flags need to be enabled:Experimental WebAssembly \nWebAssembly Garbage Collection\nWebAssembly Stringref","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"WebAssemblyCompiler supports many Julia constructs, including:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Vector{T} where T is a bitstype and Vector{Any}\nStrings\nSymbols\nMutable and immutable structs\nTuples and NamedTuples\nGlobal variables\nVarargs and keyword arguments","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Heap allocation is handled by WebAssembly's garbage collector (see wasm-GC).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Interoperability with JavaScript is quite good. Julia code can run JavaScript functions and exchange objects. This functionality allows Julia to interact with the browsers DOM.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Code must be type stable (no dynamic dispatches). In addition, several Julia constructs are not supported, including:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Multi-dimensional arrays (waiting on the Memory type PR)\nPointers\nUnion types\nException handling\nErrors\nSome integer types (Int16, Int128, ...)\nDict's (at least some uses of Dictionaries.jl work based on light testing)\nBLAS and all other C dependencies","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"WebAssemblyCompiler supports overlays and other ways to fix up code when compiling.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Once compiled to WebAssembly, you can integrate that into web apps in many ways. The examples in these docs are made with:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Literate.jl–The Julia files in /examples can run standalone, or they can be used with Franklin or Documenter (as done here).\nmdpad–This small JavaScript package provides features for single-page web apps, including auto-updates of inputs and address-bar handling.\nBulma–Any CSS framework should work. Because Documenter uses a theme based on Bulma, that is used for styling web apps.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The web apps are very Julia focused. Not much JavaScript is needed.","category":"page"}]
}
